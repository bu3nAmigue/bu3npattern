<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdn.jsdelivr.net/npm/twgl.js@4.15.0/dist/4.x/twgl-full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.4/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.4/EasePack.min.js"></script>
<script type="text/javascript"
        src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script type="module" src="ca.js"></script>
<canvas id="glCanvas"  style='z-index: 1'></canvas>
<form enctype="multipart/form-data">
<input id="upload" type=file   accept="text/json" size=30>
</form>

<script type="module">
  import { CA } from "./ca.js"

 

  const canvas = document.querySelector('#glCanvas');
  const devicePixelRatio = window.devicePixelRatio || 1;
  const quality = .5;
  const gl = canvas.getContext("webgl");
  const W = 256, H = 256;
  var videoLoaded = false;
  let ca;

  resizeGLCanvas(window.innerWidth, window.innerHeight);

  function resizeGLCanvas(width, height) {
      canvas.width = width / quality;
      canvas.height = height / quality;

      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';

      gl.viewport(0, 0, canvas.width, canvas.height);

  }


 

  const video = document.createElement('video');
  video.autoplay="";
  video.style="display:none";
  video.id="feedCam";

  const param = {
    active: true,
    model: 132,
    zoom: 0.,
    stepPerFrame: 1,
    paintMode: false,
  };

  function create_gui(){
    var gui = new dat.GUI();
    gui.add(param, 'active');
    gui.add(param, 'zoom', -0.5, .5).step(0.0001);
    gui.add(param, 'stepPerFrame', 0, 6);
    return gui;
  }

  var gui = create_gui();

  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia && video) {
      var constraints = {audio: false, video: true};

      navigator.mediaDevices.getUserMedia( constraints ).then( function ( stream ) {
          video.playsInline = true;
          video.srcObject = stream;
          video.play();
          videoLoaded = true;
          ca.loadVideoTexture(video);

      } ).catch( function ( error ) {
          console.error( 'Unable to access the camera/webcam.', error );

      } );

  } else {
      console.error( 'MediaDevices interface not available.' );
  }

  function update_model(models){
      ca.setWeights(models);
  }

  function load_model(models) {
      ca = new CA(gl, models, [W, H], gui);
      window.ca = ca;
      ca.alignment = 0;
      
      const name2idx = Object.fromEntries(models.model_names.map((s, i) => [s, i]));
      gui.add(param, 'model').options(name2idx).listen();

      ca.paint(128, 128, 1000, param.model);


      function canvasToGrid(x, y) {
        const [w, h] = ca.gridSize;
        const gridX = x / canvas.clientWidth * w * 2.0;
        const gridY = y / canvas.clientHeight * h;
        return [gridX, gridY];
      }

      $( ".target" ).change(function() {
        alert( "Handler for .change() called." );
      });

    
      function render() {
          if (videoLoaded){
              ca.updateVideoTex(video);
          }
          if (param.active) {

            const t = 2.0 * Date.now() / 1000.0;
            //ca.clearCircle(Math.sin(t * 2.0) * W / 3 + W / 2, Math.cos(t * 3.1) * H / 3 + H / 2, 20);
            for (let i=0; i<param.stepPerFrame; ++i) ca.step('all', param.zoom);
          }
          twgl.bindFramebufferInfo(gl);
          
          gl.viewport(0, 0, canvas.width, canvas.height);
          ca.draw();
          
       
          requestAnimationFrame(render);
          ca.paint(128, 128, 1000, param.model);
      }

      requestAnimationFrame(render);

      TweenLite.defaultEase = Power1.easeInOut;
      const TL = new TimelineMax({paused: true});

      TL.to(param, 4.0, {zoom: 40.0, ease: ExpoScaleEase.config(1.0, 40.0)});
      //TL.addPause();

      TL.to(ca, 1.0, {perceptionCircle: 1.0});
      //TL.addPause();
      TL.add('x');
      TL.to(ca, 1.0, {perceptionCircle: 0.0});
      TL.to(ca, 1.0, {arrowsCoef: 1.0}, '-=1');
      //TL.addPause();

      TL.to(ca, 1.0, {rotationAngle: 60.0});
      //TL.addPause();
      TL.set(ca, {alignment: 1.0}, '+=0.1');
      //TL.addPause();
      TL.set(ca, {alignment: 2.0}, '+=0.1');
      //TL.addPause();
      TL.to(ca, 1.0, {rotationAngle: 0.0});

      //TL.seek('x');
  }


  fetch('data/models.json').then(r => r.json()).then(models => {
      console.log(models);
      load_model(models);
  });

  function handleFileSelect(evt) {
      var files = evt.target.files;
      var f = files[0];
      var reader = new FileReader();

      reader.onload = (function(theFile) {
          return function(e) {
            var models = e.target.result;
            var json_models = JSON.parse(models);
         
            update_model(json_models);
          };
      })(f);

      reader.readAsText(f);
  }

  document.getElementById('upload').addEventListener('change', handleFileSelect, false);

</script>
