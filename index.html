<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdn.jsdelivr.net/npm/twgl.js@4.15.0/dist/4.x/twgl-full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.4/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.4/EasePack.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
<script type="module" src="ca.js"></script>

<div>
  <canvas id="overCanvas" width="1024" height="512" style="position: absolute;"></canvas>
  <canvas id="glCanvas" width="1024" height="512" style='z-index: 1'></canvas>
</div>

<form enctype="multipart/form-data">
<input id="upload" type=file   accept="text/json" size=30>
</form>

<script type="module">
  import { CA } from "./ca.js"

  const canvas = document.querySelector('#glCanvas');
  const devicePixelRatio = window.devicePixelRatio || 1;
  canvas.width = Math.round(canvas.clientWidth * devicePixelRatio);
  canvas.height = Math.round(canvas.clientHeight * devicePixelRatio);
  canvas.style.width = 1024 + "px";
  canvas.style.height = 512 + "px";
  const overCanvas = document.querySelector('#overCanvas');
  const gl = canvas.getContext("webgl");
  const ctx = overCanvas.getContext("2d");
  const W = 256, H = 256;
  var videoLoaded = false;

  const video = document.createElement('video');
  video.autoplay="";
  video.style="display:none";
  video.id="feedCam";

  const param = {
    active: true,
    model: 132,
    brushRadius: 16,
    zoom: 0.,
    stepPerFrame: 1,
    paintMode: false,
  };

  function create_gui(){
    var gui = new dat.GUI();
    gui.add(param, 'active');
    gui.add(param, 'brushRadius', 1, 40);
    gui.add(param, 'zoom', -0.5, .5).step(0.0001);
    gui.add(param, 'stepPerFrame', 0, 6);
    gui.add(param, 'paintMode', 0, 6);
    return gui;
  }

  var gui = create_gui();

  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia && video) {
      var constraints = {audio: false, video: true};

      navigator.mediaDevices.getUserMedia( constraints ).then( function ( stream ) {
          video.playsInline = true;
          video.srcObject = stream;
          video.play();
          videoLoaded = true;
          ca.loadVideoTexture(video);

      } ).catch( function ( error ) {
          console.error( 'Unable to access the camera/webcam.', error );

      } );

  } else {
      console.error( 'MediaDevices interface not available.' );
  }


  function load_model(models) {
      const ca = new CA(gl, models, [W, H], gui);
      window.ca = ca;
      ca.alignment = 0;
      
      const name2idx = Object.fromEntries(models.model_names.map((s, i) => [s, i]));
      gui.add(param, 'model').options(name2idx).listen();

      ca.paint(128, 128, 1000, param.model);


      function canvasToGrid(x, y) {
        const [w, h] = ca.gridSize;
        const gridX = x / canvas.clientWidth * w * 2.0;
        const gridY = y / canvas.clientHeight * h;
        return [gridX, gridY];
      }
      function getMousePos(e) {
        return canvasToGrid(e.offsetX, e.offsetY);
      }
      function getTouchPos(touch) {
        const rect = canvas.getBoundingClientRect();
        return canvasToGrid(touch.clientX - rect.left, touch.clientY - rect.top);
      }
      function touch(pos) {
        const [x, y] = pos;
        if ( param.paintMode ) {
          ca.paint(x, y, param.brushRadius, param.model);
        } else {
          ca.clearCircle(x, y, param.brushRadius);
        }
      };

      overCanvas.onmousedown = e => {
        e.preventDefault();
        if (e.buttons == 1) {
          touch(getMousePos(e));
        }
      }
      overCanvas.onmousemove = e => {
        e.preventDefault();
        if (e.buttons == 1) {
          touch(getMousePos(e));
        }
      }
      overCanvas.addEventListener("touchstart", e => {
        e.preventDefault();
        touch(getTouchPos(e.changedTouches[0]));
      });
      overCanvas.addEventListener("touchmove", e => {
        e.preventDefault();
        for (const t of e.touches) {
          touch(getTouchPos(t));
        }
      });

      $( ".target" ).change(function() {
        alert( "Handler for .change() called." );
      });

      param.benchmark = ()=>{
        document.getElementById('log').insertAdjacentHTML('afterbegin', ca.benchmark());
      }

      gui.add(param, 'benchmark');

      function render() {
          if (videoLoaded){
              ca.updateVideoTex(video);
          }
          if (param.active) {

            const t = 2.0 * Date.now() / 1000.0;
            //ca.clearCircle(Math.sin(t * 2.0) * W / 3 + W / 2, Math.cos(t * 3.1) * H / 3 + H / 2, 20);
            for (let i=0; i<param.stepPerFrame; ++i) ca.step('all', param.zoom);
          }
          twgl.bindFramebufferInfo(gl);
          const sz = 512;
          const gz = 512*devicePixelRatio;
          gl.viewport(0, 0, gz, gz);
          ca.draw();
          gl.viewport(gz, 0, gz, gz);
          //ca.draw(param.zoom);

          const d = sz/param.zoom;
          ctx.clearRect(0, 0, 2*sz, sz);
          if (param.zoom > 1.0) {
            ctx.strokeStyle = 'white';
            ctx.strokeRect(sz/2-d/2, sz/2-d/2, d, d);
          }
            
          requestAnimationFrame(render);
          ca.paint(128, 128, 1000, param.model);
      }

      requestAnimationFrame(render);

      TweenLite.defaultEase = Power1.easeInOut;
      const TL = new TimelineMax({paused: true});

      TL.to(param, 4.0, {zoom: 40.0, ease: ExpoScaleEase.config(1.0, 40.0)});
      //TL.addPause();

      TL.to(ca, 1.0, {perceptionCircle: 1.0});
      //TL.addPause();
      TL.add('x');
      TL.to(ca, 1.0, {perceptionCircle: 0.0});
      TL.to(ca, 1.0, {arrowsCoef: 1.0}, '-=1');
      //TL.addPause();

      TL.to(ca, 1.0, {rotationAngle: 60.0});
      //TL.addPause();
      TL.set(ca, {alignment: 1.0}, '+=0.1');
      //TL.addPause();
      TL.set(ca, {alignment: 2.0}, '+=0.1');
      //TL.addPause();
      TL.to(ca, 1.0, {rotationAngle: 0.0});
        if (videoLoaded) {
           
        }

      //TL.seek('x');
  }


  fetch('data/models.json').then(r => r.json()).then(models => {
      console.log(models);
      load_model(models);
  });

  function handleFileSelect(evt) {
      var files = evt.target.files;
      var f = files[0];
      var reader = new FileReader();

      reader.onload = (function(theFile) {
          return function(e) {
            var models = e.target.result;
            var json_models = JSON.parse(models);
            console.log(json_models);
            gui.destroy();
            gui = create_gui();
            load_model(json_models);
          };
      })(f);

      reader.readAsText(f);
  }

  document.getElementById('upload').addEventListener('change', handleFileSelect, false);

</script>
