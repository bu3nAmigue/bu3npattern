<!doctype html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Title -->

<title>bu3nPattern</title>
<meta property="og:title" content="bu3nPattern">

<!--Favicon-->
<link rel="icon" href="https://mathigatti.com/favicon/favicon.png">

<!--Preview Images-->

<meta property="og:image" content="https://bu3namigue.github.io/bu3npattern/demo.gif">
<link rel="image_src" href="/demo.gif">

<!--Description-->

<meta name="description" content="Apply real time pattern effects to your webcam online">
<meta property="og:description" content="Apply real time pattern effects to your webcam online">

<!--Author-->

<meta name="author" content="bu3nAmigue">
<meta name="twitter:card" content="summary_large_image">
        
        

<script src="https://cdn.jsdelivr.net/npm/twgl.js@4.15.0/dist/4.x/twgl-full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.4/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.4/EasePack.min.js"></script>
<script type="text/javascript"
        src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script type="module" src="ca.js"></script>
</head>
<body>

<canvas id="glCanvas"  style='z-index: 1'></canvas>
<form enctype="multipart/form-data">
  <p>Upload your models JSON file</p>
  <input id="upload" type=file   accept="text/json" size=60>
  <p>Generate your own pattern from custom images from <a href="https://colab.research.google.com/drive/1KMlVFi2zXhE0_PHCBXC07oblcJf9E13s">here</a></p>
</form>

<script type="module">
  import { CA } from "./ca.js"

  const canvas = document.querySelector('#glCanvas');
  const devicePixelRatio = window.devicePixelRatio || 1;
  const quality = .5;
  const gl = canvas.getContext("webgl");
  const W = 256, H = 256;
  var videoLoaded = false;
  let ca;

  resizeGLCanvas(window.innerWidth, window.innerHeight);

  function resizeGLCanvas(width, height) {
      canvas.width = width / quality;
      canvas.height = height / quality;

      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';

      gl.viewport(0, 0, canvas.width, canvas.height);

  }


 

  const video = document.createElement('video');
  video.autoplay="";
  video.style="display:none";
  video.id="feedCam";

  const param = {
    active: true,
    model: 132,
    zoom: 0.,
    speed: 1,
    paintMode: false,
  };

  function create_gui(){
    var gui = new dat.GUI();
    gui.add(param, 'active');
    gui.add(param, 'zoom', -0.5, .5).step(0.0001);
    gui.add(param, 'speed', 0, 6);
    return gui;
  }

  var gui = create_gui();
  let name2idx, modelController;

  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia && video) {
      var constraints = {audio: false, video: true};

      navigator.mediaDevices.getUserMedia( constraints ).then( function ( stream ) {
          video.playsInline = true;
          video.srcObject = stream;
          video.play();
          videoLoaded = true;
          ca.loadVideoTexture(video);

      } ).catch( function ( error ) {
          console.error( 'Unable to access the camera/webcam.', error );

      } );

  } else {
      console.error( 'MediaDevices interface not available.' );
  }

  function update_model(models){
      ca.setWeights(models);
      name2idx = Object.fromEntries(models.model_names.map((s, i) => [s, i]));
      gui.remove(modelController);
      modelController = gui.add(param, 'model').options(name2idx).listen();
      param.model=0;
  }

  function load_model(models) {
      ca = new CA(gl, models, [W, H], gui);
      window.ca = ca;
      ca.alignment = 0;
      
      name2idx = Object.fromEntries(models.model_names.map((s, i) => [s, i]));
      modelController = gui.add(param, 'model').options(name2idx).listen();

      ca.paint(128, 128, 1000, param.model);


      $( ".target" ).change(function() {
        alert( "Handler for .change() called." );
      });

    
      function render() {
          if (videoLoaded){
              ca.updateVideoTex(video);
          }

          if (param.active) {
            //ca.clearCircle(Math.sin(t * 2.0) * W / 3 + W / 2, Math.cos(t * 3.1) * H / 3 + H / 2, 20);
            for (let i=0; i<param.speed; ++i) ca.step('all', param.zoom);
          }

          twgl.bindFramebufferInfo(gl);
          gl.viewport(0, 0, canvas.width, canvas.height);
          ca.draw();
       
          requestAnimationFrame(render);
          ca.paint(128, 128, 1000, param.model);
      }

      requestAnimationFrame(render);
  }


  fetch('data/models.json').then(r => r.json()).then(models => {
      console.log(models);
      load_model(models);
  });

  function handleFileSelect(evt) {
      var files = evt.target.files;
      var f = files[0];
      var reader = new FileReader();

      reader.onload = (function(theFile) {
          return function(e) {
            var models = e.target.result;
            var json_models = JSON.parse(models);
         
            update_model(json_models);
          };
      })(f);

      reader.readAsText(f);
  }

  document.getElementById('upload').addEventListener('change', handleFileSelect, false);

</script>
</body>
